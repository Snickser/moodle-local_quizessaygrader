<?php
// This file is part of Moodle - https://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.
// Generated by DeepSeek.

/**
 * Library file for plugin 'local_quizessaygrader'.
 *
 * @package     local_quizessaygrader
 * @copyright   2025 Alex Orlov <snickser@gmail.com>
 * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

define('CLI_SCRIPT', true);

require_once(__DIR__ . '/../../../config.php');
require_once($CFG->dirroot . '/mod/quiz/locallib.php');
require_once($CFG->libdir . '/clilib.php');

require_once($CFG->dirroot . '/lib/enrollib.php');
require_once($CFG->dirroot . '/mod/quiz/locallib.php');
require_once($CFG->dirroot . '/lib/gradelib.php');
require_once($CFG->dirroot . '/question/engine/lib.php');
require_once($CFG->dirroot . '/mod/quiz/classes/grade_calculator.php');
use mod_quiz\quiz_settings;

// Error reporting settings.
error_reporting(E_ALL);
ini_set('display_errors', 1);
ini_set('log_errors', 1);

// Command line parameters processing.
[$options, $unrecognized] = cli_get_params([
    'help' => false,
    'courseid' => 0,
    'quizid' => 0,
    'userid' => 0,
    'verbose' => false,
    'dryrun' => false,
    'maxusers' => 0,
], [
    'h' => 'help',
    'c' => 'courseid',
    'q' => 'quizid',
    'u' => 'userid',
    'v' => 'verbose',
    'd' => 'dryrun',
    'm' => 'maxusers',
]);

if ($options['help']) {
    echo "Script for transferring essay grades between quiz attempts

Options:
-h, --help        Print this help
-c, --courseid    Process only specified course
-q, --quizid      Process only specified quiz
-u, --userid      Process only specified user
-v, --verbose     Verbose output
-d, --dryrun      Test mode (no DB changes)
-m, --maxusers    Maximum number of users to process

Examples:
php transfer_essay_grades.php
php transfer_essay_grades.php --courseid=2 --verbose
php transfer_essay_grades.php --quizid=5 --dryrun --maxusers=100
";
    exit(0);
}

/**
 * Logs a message to console output.
 *
 * @param string $message The message to log.
 * @param bool $verbose Whether to show in verbose mode only.
 * @param bool $force Whether to force output regardless of verbose setting.
 */
function log_message($message, $verbose = false, $force = false) {
    if ($verbose || $force) {
        cli_writeln($message);
    }
}

/**
 * Checks if a quiz contains essay questions.
 *
 * @param int $quizid The quiz ID to check.
 * @return bool True if quiz contains essay questions, false otherwise.
 */
function quiz_has_essay_questions($quizid) {
    global $DB;

    $sql = "SELECT COUNT(q.id)
            FROM {quiz_slots} qs
            JOIN {question_references} qr ON qr.itemid = qs.id 
                AND qr.component = 'mod_quiz' 
                AND qr.questionarea = 'slot'
            JOIN {question_bank_entries} qbe ON qbe.id = qr.questionbankentryid
            JOIN {question_versions} qv ON qv.questionbankentryid = qbe.id
            JOIN {question} q ON q.id = qv.questionid
            WHERE qs.quizid = ? AND q.qtype = 'essay'";

    return $DB->count_records_sql($sql, [$quizid]) > 0;
}

try {
    $gradetype = get_config('local_quizessaygrader', 'gradetype');

    $transaction = $DB->start_delegated_transaction();
    $starttime = time();
    $processedusers = 0;

    log_message("Starting processing at " . date('Y-m-d H:i:s') .
               ($options['dryrun'] ? " (TEST MODE)" : ""), true);

    // Get list of courses.
    $courses = $DB->get_records_select(
        'course',
        $options['courseid'] > 0 ? 'id = ?' : '1=1',
        $options['courseid'] > 0 ? [$options['courseid']] : []
    );

    foreach ($courses as $course) {
        if ($options['maxusers'] > 0 && $processedusers >= $options['maxusers']) {
            break;
        }

        log_message("\nCourse: " . format_string($course->fullname) . " (ID: {$course->id})", true);

        // Get quizzes in course.
        $quizzes = $DB->get_records_select(
            'quiz',
            $options['quizid'] > 0 ? 'course = ? AND id = ?' : 'course = ?',
            $options['quizid'] > 0 ? [$course->id, $options['quizid']] : [$course->id]
        );

        foreach ($quizzes as $quiz) {
            if ($options['maxusers'] > 0 && $processedusers >= $options['maxusers']) {
                break 2;
            }

            log_message("  Quiz: {$quiz->name} (ID: {$quiz->id})", $options['verbose']);

            if (!quiz_has_essay_questions($quiz->id)) {
                continue;
            }

            // Get users with attempts (ordered by attempt ASC - oldest first).
            $attempts = $DB->get_records_select(
                'quiz_attempts',
                $options['userid'] > 0 ? 'quiz = ? AND state = ? AND userid = ?' : 'quiz = ? AND state = ?',
                $options['userid'] > 0 ? [$quiz->id, 'finished', $options['userid']] : [$quiz->id, 'finished'],
                'userid, attempt ASC' // Sort by attempt number ascending.
            );

            // Group attempts by user (now first attempt is the earliest).
            $usersattempts = [];
            foreach ($attempts as $attempt) {
                $usersattempts[$attempt->userid][] = $attempt;
            }

            foreach ($usersattempts as $userid => $userattempts) {
                if (!is_enrolled(context_course::instance($course->id), $userid)) {
                    continue;
                }

                if ($options['maxusers'] > 0 && $processedusers >= $options['maxusers']) {
                    break 3;
                }

                if (count($userattempts) < 2) {
                    continue;
                }

                $user = $DB->get_record('user', ['id' => $userid], 'id, firstname, lastname');
                log_message("    User: {$user->firstname} {$user->lastname} (ID: {$user->id})", $options['verbose']);

                // Get two most recent attempts.
                $lastattempt = end($userattempts); // Newest attempt.
                prev($userattempts);
                $prevattempt = current($userattempts); // Previous attempt.

                log_message("      Transferring grades from attempt #{$prevattempt->attempt}" .
                "to attempt #{$lastattempt->attempt}", $options['verbose']);

                try {
                    $count = transfer_essay_grades(
                        $prevattempt->id,
                        $lastattempt->id,
                        $options['verbose'],
                        $options['dryrun'],
                        $gradetype
                    );
                    if ($count > 0) {
                        $processedusers++;
                        log_message("      Successfully transferred grades: {$count}", $options['verbose']);
                    }
                } catch (Exception $e) {
                    log_message("      Error: " . $e->getMessage(), true);
                    continue;
                }
            }
        }
    }

    // Commit changes.
    if (!$options['dryrun']) {
        $transaction->allow_commit();
        log_message("Changes saved to database", true);
    } else {
        $DB->force_transaction_rollback();
        log_message("Transaction rolled back (test mode)", true);
    }

    $totaltime = time() - $starttime;
    log_message("\nProcessing completed in {$totaltime} seconds", true);
    log_message("Total users processed: {$processedusers}", true);
} catch (Exception $e) {
    $DB->force_transaction_rollback();
    log_message("Critical error: " . $e->getMessage(), true);
    exit(1);
}

/**
 * Transfers essay grades from one quiz attempt to another.
 *
 * @param int $sourceattemptid The source attempt ID to copy grades from.
 * @param int $targetattemptid The target attempt ID to copy grades to.
 * @param bool $verbose Whether to show verbose output.
 * @param bool $dryrun Whether to run in test mode (no DB changes).
 * @param int $gradetype The grading type (0 for normal, 1 for alternative).
 * @return int Number of grades successfully transferred.
 * @throws moodle_exception If the transfer fails.
 */
function transfer_essay_grades($sourceattemptid, $targetattemptid, $verbose = false, $dryrun = false, $gradetype = 0) {
    global $DB, $CFG;
    require_once($CFG->dirroot . '/mod/quiz/locallib.php');
    require_once($CFG->libdir . '/gradelib.php');

    try {
        // Get attempt data.
        $sourceattempt = $DB->get_record('quiz_attempts', ['id' => $sourceattemptid], '*', MUST_EXIST);
        $targetattempt = $DB->get_record('quiz_attempts', ['id' => $targetattemptid], '*', MUST_EXIST);
        $quiz = $DB->get_record('quiz', ['id' => $targetattempt->quiz], '*', MUST_EXIST);
        $cm = get_coursemodule_from_instance('quiz', $quiz->id, $quiz->course, false, MUST_EXIST);

        // Load question usage for attempts.
        $sourcequba = question_engine::load_questions_usage_by_activity($sourceattempt->uniqueid);
        $targetquba = question_engine::load_questions_usage_by_activity($targetattempt->uniqueid);

        $count = 0;
        $totalessays = 0;
        $skippedalreadygraded = 0;

        // Get question slots.
        $slots = $DB->get_records('quiz_slots', ['quizid' => $quiz->id], 'slot');

        foreach ($slots as $slot) {
            try {
                $sourceqa = $sourcequba->get_question_attempt($slot->slot);
                $question = $sourceqa->get_question();

                if ($question->get_type_name() == 'essay') {
                    $totalessays++;

                    // Get grade from source attempt.
                    $grade = $sourceqa->get_fraction();
                    $maxmark = $sourceqa->get_max_mark();
                    $actualgrade = $grade * $maxmark;

                    // Check grade in target attempt.
                    $targetqa = $targetquba->get_question_attempt($slot->slot);
                    $targetgrade = $targetqa->get_fraction();

                    // Skip conditions.
                    $maxgrade = $maxmark;
                    if ($gradetype) {
                        $maxgrade = $actualgrade;
                    }
                    if (is_null($grade) || $actualgrade <= 0 || $actualgrade < $maxgrade) {
                        log_message("        Essay (slot {$slot->slot}): grade $actualgrade (not transferred)", $verbose);
                        continue;
                    }
                    if (!is_null($targetgrade) && $targetgrade) {
                        $skippedalreadygraded++;
                        log_message("        Essay (slot {$slot->slot}): skipped (grade already exists)", $verbose);
                        continue;
                    }

                    // Get feedback from last step.
                    $feedback = 'auto';
                    $laststep = $sourceqa->get_last_step();
                    if ($laststep->has_behaviour_var('comment')) {
                        $text = $laststep->get_behaviour_var('comment');
                        if (strlen($text)) {
                            $feedback = $text;
                        }
                    } else if ($laststep->has_behaviour_var('feedback')) {
                        $feedback = $laststep->get_behaviour_var('feedback');
                    }

                    if (!$dryrun) {
                        // Set grade using standard API.
                        $targetqa->manual_grade($feedback, $actualgrade, FORMAT_HTML);
                        $count++;
                    }

                    log_message("        Essay (slot {$slot->slot}): transferred {$actualgrade}/{$maxmark}" .
                        ($dryrun ? " (test mode)" : ""), $verbose);
                }
            } catch (Exception $e) {
                log_message("        Slot {$slot->slot} error: " . $e->getMessage(), true);
                continue;
            }
        }

        if (!$dryrun && $count > 0) {
            // Save changes.
            question_engine::save_questions_usage_by_activity($targetquba);

            // Recalculate total grade.
            $targetattempt->sumgrades = $targetquba->get_total_mark();
            $DB->update_record('quiz_attempts', $targetattempt);
        }

        log_message("      Summary: essay questions: {$totalessays}, " .
            "transferred: {$count}, " .
            "skipped (grade exists): {$skippedalreadygraded}" .
            ($dryrun ? " (test mode)" : ""), true);

        return $count;
    } catch (Exception $e) {
        throw new moodle_exception('transferfailed', 'error', '', null, $e->getMessage());
    }
}
